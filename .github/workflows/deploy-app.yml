name: 'Deploy Application to AKS'

on:
  workflow_run:
    workflows: ["Build and Push Application", "Terraform Apply"]
    types: [completed]
    branches: [main]
  workflow_dispatch:
    inputs:
      environment:
        description: 'Environment to deploy to'
        required: true
        default: 'dev'
        type: choice
        options: [dev, test, prod]
      image_tag:
        description: 'Image tag to deploy (e.g., latest or main-<sha>)'
        required: false
        default: 'latest'

env:
  REGISTRY: cst8918weatheracr.azurecr.io

jobs:
  deploy:
    name: 'Deploy to AKS'
    runs-on: ubuntu-latest
    # run when the upstream workflows succeed, or when manually dispatched
    if: ${{ github.event.workflow_run.conclusion == 'success' || github.event_name == 'workflow_dispatch' }}
    strategy:
      matrix:
        # when manual, deploy to the chosen env; otherwise deploy to dev & test
        environment: ${{ github.event_name == 'workflow_dispatch' && fromJSON(format('["{0}"]', github.event.inputs.environment)) || fromJSON('["dev", "test"]') }}
    environment: ${{ matrix.environment }}

    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Azure Login
        uses: azure/login@v1
        with:
          creds: ${{ secrets.AZURE_CREDENTIALS }}

      - name: Set up kubectl
        uses: azure/setup-kubectl@v3
        with:
          version: '1.28.0'

      - name: Get AKS credentials
        run: |
          # RG pattern updated for GROUP 11
          az aks get-credentials \
            --resource-group cst8918-final-project-group-11-${{ matrix.environment }} \
            --name ${{ matrix.environment }}-weather-aks \
            --overwrite-existing

      - name: Deploy Weather App
        run: |
          set -euo pipefail

          IMAGE_TAG="${{ github.event_name == 'workflow_dispatch' && github.event.inputs.image_tag || 'latest' }}"
          # replicas: prod=3, test=1, dev=2
          if [ "${{ matrix.environment }}" = "prod" ]; then REPLICAS=3;
          elif [ "${{ matrix.environment }}" = "test" ]; then REPLICAS=1;
          else REPLICAS=2; fi

          NS="weather-app-${{ matrix.environment }}"

          echo "Using namespace: ${NS}"
          kubectl create namespace "${NS}" --dry-run=client -o yaml | kubectl apply -f -

          echo "Deploying Redis..."
          kubectl apply -f - << 'EOL'
          apiVersion: apps/v1
          kind: Deployment
          metadata:
            name: redis
            namespace: ${NS}
          spec:
            replicas: 1
            selector:
              matchLabels: { app: redis }
            template:
              metadata:
                labels: { app: redis }
              spec:
                containers:
                  - name: redis
                    image: redis:7-alpine
                    ports:
                      - containerPort: 6379
          ---
          apiVersion: v1
          kind: Service
          metadata:
            name: redis-service
            namespace: ${NS}
          spec:
            selector: { app: redis }
            ports:
              - port: 6379
                targetPort: 6379
          EOL

          echo "Deploying Backend..."
          kubectl apply -f - << EOL
          apiVersion: apps/v1
          kind: Deployment
          metadata:
            name: weather-backend
            namespace: ${NS}
          spec:
            replicas: ${REPLICAS}
            selector:
              matchLabels: { app: weather-backend }
            template:
              metadata:
                labels: { app: weather-backend }
              spec:
                containers:
                  - name: weather-backend
                    image: ${REGISTRY}/weather-backend:${IMAGE_TAG}
                    ports:
                      - containerPort: 3000
                    env:
                      - name: OPENWEATHER_API_KEY
                        value: "${{ secrets.OPENWEATHER_API_KEY }}"
                      - name: REDIS_HOST
                        value: "redis-service"
                      - name: REDIS_PASSWORD
                        value: ""
                      - name: REDIS_PORT
                        value: "6379"
                      - name: REDIS_TLS
                        value: "false"
          ---
          apiVersion: v1
          kind: Service
          metadata:
            name: weather-backend-service
            namespace: ${NS}
          spec:
            selector: { app: weather-backend }
            ports:
              - port: 3000
                targetPort: 3000
          EOL

          echo "Deploying Frontend..."
          kubectl apply -f - << EOL
          apiVersion: apps/v1
          kind: Deployment
          metadata:
            name: weather-frontend
            namespace: ${NS}
          spec:
            replicas: ${REPLICAS}
            selector:
              matchLabels: { app: weather-frontend }
            template:
              metadata:
                labels: { app: weather-frontend }
              spec:
                containers:
                  - name: weather-frontend
                    image: ${REGISTRY}/weather-frontend:${IMAGE_TAG}
                    ports:
                      - containerPort: 3000
                    env:
                      - name: BACKEND_URL
                        value: "http://weather-backend-service:3000"
                      - name: NODE_ENV
                        value: "production"
          ---
          apiVersion: v1
          kind: Service
          metadata:
            name: weather-frontend-service
            namespace: ${NS}
          spec:
            selector: { app: weather-frontend }
            ports:
              - port: 80
                targetPort: 3000
            type: LoadBalancer
          EOL

          echo "Waiting for deployments to become available..."
          kubectl wait --for=condition=available --timeout=300s deployment/redis -n "${NS}"
          kubectl wait --for=condition=available --timeout=300s deployment/weather-backend -n "${NS}"
          kubectl wait --for=condition=available --timeout=300s deployment/weather-frontend -n "${NS}"

          echo "Getting LoadBalancer IP..."
          for i in {1..10}; do
            EXTERNAL_IP="$(kubectl get service weather-frontend-service -n "${NS}" -o jsonpath='{.status.loadBalancer.ingress[0].ip}' 2>/dev/null || true)"
            if [ -n "${EXTERNAL_IP}" ]; then
              echo "Deployed ${NS}!"
              echo "URL: http://${EXTERNAL_IP}"
              exit 0
            fi
            echo "Waiting for LoadBalancer IP... (attempt $i/10)"
            sleep 30
          done

          echo "LoadBalancer IP not ready yet."
          kubectl get svc -n "${NS}" weather-frontend-service -o wide
